"""
This module handles the widget to access the cropped images generated by the
gallery widget and display them in a gui application for training
"""


# Logging

import logging
from omero_screen_napari.omero_data_singleton import omero_data
from magicgui import magicgui
from magicgui import magic_factory
from magicgui.widgets import Container, RadioButtons
import napari


class ImageNavigator:
    def __init__(self):
        self.current_index = 0

    def next_image(self):
        if omero_data.selected_images:
            self.current_index = (self.current_index + 1) % len(omero_data.selected_images)
            self.update_image()

    def previous_image(self):
        if omero_data.selected_images:
            self.current_index = (self.current_index - 1) % len(omero_data.selected_images)
            self.update_image()

    def update_image(self):
        viewer = napari.current_viewer()
        current_choices = class_choice.choices
        class_choice.changed.disconnect(assign_class)
        viewer.layers.clear()
        if omero_data.selected_images:
            image = omero_data.selected_images[self.current_index]
            # Check the number of channels and adjust accordingly
            if image.ndim == 2:
                # Single channel, load as greyscale
                viewer.add_image(image, name=f'Cropped Image {self.current_index}', colormap='gray')
            elif image.shape[-1] == 2:
                # Two channels, map first to green and second to red
                combined_image = np.zeros((*image.shape[:-1], 3), dtype=image.dtype)
                combined_image[..., 1] = image[..., 0]  # Green channel
                combined_image[..., 0] = image[..., 1]  # Red channel
                viewer.add_image(combined_image, name=f'Cropped Image {self.current_index}')
            else:
                # Three channels, load as RGB
                viewer.add_image(image, name=f'Cropped Image {self.current_index}')
        class_choice.choices = current_choices
        class_choice.changed.connect(assign_class)
        update_class_choice()


image_navigator = ImageNavigator()

@magicgui(call_button="Load Images")
def load_image():
    if not omero_data.selected_images:
        print("No images to load.")
        return
    selected_images_length = len(omero_data.selected_images)
    omero_data.selected_classes = ["unassigned" for _ in range(selected_images_length)]
    image_navigator.current_index = 0
    image_navigator.update_image()

@magicgui(call_button="Next Image")
def next_image():
    image_navigator.next_image()

@magicgui(call_button="Previous Image")
def previous_image():
    image_navigator.previous_image()

def assign_class(class_name: str):
    if omero_data.selected_classes:
        omero_data.selected_classes[image_navigator.current_index] = class_name

class_options = ["unassigned", "class1", "class2", "class3", "class4"]
class_choice = RadioButtons(label="Select class:", choices=class_options, value="unassigned")
class_choice.changed.connect(assign_class)

def update_class_choice():
    if omero_data.selected_classes:
        current_class = omero_data.selected_classes[image_navigator.current_index]
    else:
        current_class = "unassigned"
    class_choice.value = current_class if current_class in class_choice.choices else "unassigned"

@magicgui(call_button="Enter", text_input={"label": "Class name"})
def add_class(text_input: str):
    if text_input and text_input not in class_choice.choices:
        class_choice.choices = list(class_choice.choices) + [text_input]
        add_class.text_input.value = ""

@magicgui(call_button="Reset class options")
def reset_class_options():
    class_choice.choices = ["unassigned"]

def training_widget():
    return Container(widgets=[load_image, previous_image, next_image, add_class, class_choice, reset_class_options])

# Create a list that has the same length as omero_data.selected_images, and contains the string 'unassigned'
#['unassigned, 'unassigned' etc.]
#In the widget Generate two fields with label1 and label2 and enter buttoms.
#When the enter button is pressed, the the list shoud be updated to either label 1 or label2 at the same index as the
#current image
# How can we expert the labels and the images and make then accessible for training a model.
# Think about how to experot the labels and trainming data as local files that can be accessed for training